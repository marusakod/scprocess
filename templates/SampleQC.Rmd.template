---
title: "Cell-level QC"
author:
- name: ${YOUR_NAME}
  affiliation: 
  - ${AFFILIATION}
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  workflowr::wflow_html:
    code_folding: hide
    toc: true
    toc_float: true
    number_sections: false
---



```{r setup_knitr, include=FALSE}
library('BiocStyle')
knitr::opts_chunk$set( autodep=TRUE, cache=TRUE, cache.lazy=FALSE, dev='png', 
fig.path = "${PROJ_DIR}/public/figure/${SHORT_TAG}_SampleQC.Rmd/"
)
knitr::opts_knit$set( root.dir='..' )
# workflowr::wflow_build(files='analysis/${SHORT_TAG}_qc.Rmd', view=F, verbose=T, delete_cache=T)
```


```{r setup_helpers, message=FALSE, cache=FALSE, include = FALSE}
source('code/utils.R')
source('code/qc.R')
n_cores     = ${threads}
setDTthreads(n_cores)
```


```{r setup_input, include = FALSE}
# define qc metric files
meta_f      = "${meta_f}"
qc_f        = "${qc_dt_f}"
keep_f      = "${qc_keep_f}"

# set default values
ambient_method  = "${AMBIENT_METHOD}"
hard_min_counts = ${QC_HARD_MIN_COUNTS}
hard_min_feats  = ${QC_HARD_MIN_FEATS}
hard_max_mito   = ${QC_HARD_MAX_MITO}
min_counts      = ${QC_MIN_COUNTS}
min_feats       = ${QC_MIN_FEATS}
min_mito        = ${QC_MIN_MITO}
max_mito        = ${QC_MAX_MITO}
min_splice      = ${QC_MIN_SPLICE}
max_splice      = ${QC_MAX_SPLICE}
min_cells       = ${QC_MIN_CELLS}

# specifications for SampleQC
qc_names    = c('log_counts', 'log_feats', 'logit_mito', 'logit_spliced')
qc_lu       = c('library size', 'no. of features', 'mito pct.', 'spliced pct.') %>% 
  setNames(qc_names)
```


```{r load_qc_values, include = FALSE}
qc_dt       = fread(qc_f)
keep_dt     = fread(keep_f)
kept_dt     = qc_dt[ cell_id %in% keep_dt$cell_id ]
```

```{r load_metadata, include = FALSE}
# get nice ordering for samples
meta_dt     = fread(meta_f)
s_lvls      = meta_dt$sample_id %>% intersect(unique(qc_dt$sample_id))
```

```{r make_threshold_dt, include = FALSE}
thrshlds_ls = list(
  log_counts    = log10(min_counts),
  log_feats     = log10(min_feats),
  logit_mito    = c(qlogis(min_mito), qlogis(max_mito)),
  logit_spliced = c(qlogis(min_splice), qlogis(max_splice))
)
thrshlds_dt = lapply(names(thrshlds_ls), function(nn) {
  data.table( qc_var = nn, cut_point = thrshlds_ls[[ nn ]] )
  }) %>% rbindlist
thrshlds_dt = thrshlds_dt[ !is.infinite(cut_point) ]
```


## Sample QC metric ranges, marginals{.tabset}

An overview of quality control (QC) metrics for all samples, both before and after filtering. The QC metrics include:

* `no. cells` : total number of barcodes called as cells for each sample. Samples with less than `r min_cells` cells are excluded from further analysis.

* `library size` : sum of counts across all features for each cell with log-transformed values displayed. Cells with library size less than `r min_counts` are excluded from further analysis.

* `no. of features` : number of unique features with non-zero counts for each cell with log-transformed values displayed. Cells with less than `r min_feats` unique features are excluded from further analysis.

* `mito pct.` : the proportion of reads that mapped to genes in the mitochondrial genome. High proportions are indicative of poor-quality cells (compromised membranes allow individual RNA molecules to escape while retaining mitochondria,
leading to an increased relative abundance of mitochondrial transcript) or nuclei (incomplete removal of cytoplasm). Logit-transformed values are displayed as applying the logit (inverse logistic) transformation to mitochondrial proportions yields approximately Gaussian distributions. Cells with mitochondrial proportions exceeding `r max_mito` are excluded from further analysis. 

* `spliced pct.` : the proportion of spliced reads. In single-nuclei RNA sequencing, high spliced proportions may indicate inadequate removal of cytoplasmic material from the nuclei.
Logit-transformed values are displayed as applying the logit  (inverse logistic) transformation to spliced proportions results in approximately Gaussian distributions.
Cells with spliced proportions greater than `r max_splice` are excluded from further analysis. 


```{r plot_qc_ranges_marginals, fig.height = 10, fig.width = 9, results = 'asis'}
suppressWarnings({
  cat("### Pre-QC\n")
  print(plot_qc_ranges_marginals(qc_dt, s_lvls, qc_names, qc_lu, thrshlds_dt, ambient_method))
  cat("\n\n")
  cat("### After light QC\n")
  print(plot_qc_ranges_marginals(kept_dt, s_lvls, qc_names, qc_lu, thrshlds_dt, ambient_method))
  cat("\n\n")
})
```

## Sample QC metric ranges, pairwise{.tabset}

Summary of QC metrics for each sample is obtained by aggregating transcript values across all cells. For each sample, the QC metrics previously described above - library size, number of features, mitochondrial proportion, and spliced proportion - are calculated and visualized in a
pairwise QC plot to facilitate the exploration of relationships between all pairs of QC metrics. 


```{r plot_qc_ranges_pairwise, fig.height = 7, fig.width = 8, results = 'asis'}
cat("### Pre-QC\n")
print(plot_qc_ranges_pairwise(qc_dt, qc_names, qc_lu, thrshlds_dt, ambient_method))
cat("\n\n")
cat("### After light QC\n")
print(plot_qc_ranges_pairwise(kept_dt, qc_names, qc_lu, thrshlds_dt, ambient_method))
cat("\n\n")
```

## QC metrics scatterplots{.tabset}

Pairwise relationships of (QC) metrics at individual cell level, rather than aggregating data across samples. 

```{r plot_qc_metric_scatters, fig.height = 6, fig.width = 8, results = 'asis'}
for (s in s_lvls) {
  qc_tmp      = qc_dt[ sample_id == s ]
  if (nrow(qc_tmp) == 1)
    next
  cat('### ', s, '\n')
  print(plot_qc_metric_scatter(qc_tmp, qc_names, qc_lu, thrshlds_dt))
  cat('\n\n')
}
```

## How many cells and samples retained?

Table summarizing the number of cells before and after qc filtering. [some_number] samples are excluded from further analysis due to insufficient number of cells.

```{r print_totals_excluded}
calc_qc_summary(qc_dt, kept_dt) %>% knitr::kable()
```

