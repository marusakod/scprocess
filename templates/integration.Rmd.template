---
title: "Integration with Harmony"
author:
- name: ${YOUR_NAME}
  affiliation: 
  - ${AFFILIATION}
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  workflowr::wflow_html:
    code_folding: hide
    toc: true
    toc_float: true
    number_sections: false
---



```{r setup_knitr, include=FALSE}
library('BiocStyle')
knitr::opts_chunk$set( autodep=TRUE, cache=TRUE, cache.lazy=FALSE, dev='png', 
fig.path = "${PROJ_DIR}/public/figure/${SHORT_TAG}_integration.Rmd/"
)
knitr::opts_knit$set( root.dir='..' )
```


```{r setup_helpers, message=FALSE, cache=FALSE, include = FALSE}
source('code/utils.R')
source('code/ambient.R')
source('code/integration.R')
n_cores     = ${threads}
setDTthreads(n_cores)
```


```{r setup_input, include = FALSE}
# inputs via reprocessing
sce_all_f   = "${sce_all_f}"
qc_f        = "${qc_dt_f}"
keep_f      = "${qc_keep_f}"

# define QC lookups
qc_names    = c('log_counts', 'log_feats', 'logit_mito', 'logit_spliced')
qc_lu       = c('library size', 'no. of features', 'mito pct.', 'spliced pct.') %>% 
  setNames(qc_names)

# define harmony inputs
hmny_f      = "${hmny_f}"
hvgs_f      = "${hmny_hvgs_f}"
res_ls      = "${INT_RES_LS}" %>%
 str_split(pattern = ',') %>% unlist() %>% as.numeric()
sel_res     = ${INT_SEL_RES}
dbl_cl_prop = ${INT_DBL_CL_PROP}
```


```{r load_qc_results, include = FALSE}
keep_ids    = fread(keep_f) %>% use_series('cell_id')
qc_melt     = fread(qc_f) %>% 
  melt(id = 'cell_id', measure = qc_names, val = 'qc_val', var = 'qc_var') %>%
  .[, qc_full := qc_lu[ qc_var ] ] %>%
  .[, qc_var  := factor(qc_var, levels = qc_names) ] %>%
  .[, qc_full := fct_reorder(qc_full, as.integer(qc_var)) ] %>% 
  .[ !is.na(qc_val) ]
```

```{r load_harmony_results, include = FALSE}
hmny_all    = fread(hmny_f)
```

```{r extract_dbl_checks, include = FALSE}
hmny_dbl    = hmny_all %>% 
  .[, .(sample_id, cell_id, UMAP1 = dbl_UMAP1, UMAP2 = dbl_UMAP2, is_dbl, dbl_cluster)]
```

```{r extract_normal_harmony, include = FALSE}
hmny_dt    = hmny_all[ !is.na(UMAP1) ] %>% 
  .[, c("sample_id", "cell_id", "integration", "UMAP1", "UMAP2", 
    str_subset(names(hmny_all), "RNA_snn_res")), with = FALSE]
```


```{r extract_clusters, include = FALSE}
clusts_dt   = hmny_dt %>% 
  melt(measure = patterns('RNA_snn_res'), var = 'resolution', val = 'cluster') %>% 
  .[, .(integration, sample_id, cell_id, 
    resolution = str_extract(resolution, "(?<=res\\.)(.+)"), cluster)]
```

Cells that passed quality control filtering were integrated with `Harmony` together with doublets identified using scDblfinder. Clustering of cells at a high resolution is then performed. Cells that appear in clusters which are enriched in doublets are excluded from further analysis.
Integration of cells and clustering is repeated after removing doublet enriched clusters.


## Check doublets over UMAP

The plot displays a binned UMAP with the proportion of doublets as well as the number of doublets in each bin. 

```{r plot_doublet_harmony, fig.height = 5, fig.width = 11}
g_dbl   = plot_umap_doublets(hmny_dbl)
g_dens  = plot_umap_density(hmny_dbl[, .(cell_id, UMAP1, UMAP2) ])
g       = g_dbl + g_dens
print(g)
```

## Doublet proportions in clusters

The plot shows the proportion of doublets for each cluster in relation to the total number of cells in that cluster. Clusters with a doublet proportion exceeding `r dbl_cl_prop` are excluded from further analysis.

```{r plot_doublet_clusters, fig.height = 4, fig.width = 6}
( plot_doublet_clusters(hmny_dbl, dbl_cl_prop) )
```

## Clusters over UMAP{.tabset}

Clustering of data is performed at different resolution values. For each value the clusters are displayed over a UMAP together with a plot showing the density of cells. 

```{r plot_clusters_harmony, fig.height = 5, fig.width = 11, results = "asis"}
for (res in res_ls) {
  cat('### ', res, '\n')
  g_cl    = plot_umap_cluster(
    umap_dt   = hmny_dt[, .(cell_id, UMAP1, UMAP2) ], 
    clust_dt  = hmny_dt[, .(cell_id, cluster = get(paste0('RNA_snn_res.', res))) ],
    name      = sprintf('res = %s', res))
  g_dens  = plot_umap_density(hmny_dt[, .(cell_id, UMAP1, UMAP2) ])
  g       = g_cl + g_dens
  print(g)
  cat('\n\n')
}
```

## Evaluating cluster distribution across samples{.tabset}

This plot visualizes the relationship between the entropy of clusters and the maximum percentage of cells from a single sample within each cluster (higher values suggest that a cluster predominantly contains cells from a single sample).
Entropy measures how evenly distributed cells are across samples within each clusterâ€”higher entropy indicates that cells from different samples are more evenly distributed, while lower entropy suggests that a cluster is dominated by cells from a small number of samples.

```{r plot_entropy_selected_clusters, fig.height = 5, fig.width = 7, results = "asis"}
for (res in res_ls) {
  cat('### ', res, '\n')
  input_dt  = hmny_dt[, .(sample_id, cell_id, cluster = get(paste0('RNA_snn_res.', res)))]
  suppressWarnings(print(plot_cluster_entropies(input_dt, what = "norm")))
  cat('\n\n')
}
```

## Check QC metrics of clusters{.tabset}

Distributions of QC metrics (library size, number of features, mitochondrial proportion, and spliced proportion) are shown for each cluster across different resolution values.

```{r plot_qc_distns, fig.height = 8, fig.width = 10, results = 'asis'}
for (res in res_ls) {
  cat('### ', res, '\n')
  suppressWarnings(print(plot_cluster_qc_distns(
    qc_melt, 
    clust_dt  = hmny_dt[, .(cell_id, cluster = get(paste0('RNA_snn_res.', res)))], 
    name      = res)))
  cat('\n\n')
}
```

