---
title: "Multiplexing diagnostics"
author:
- name: ${YOUR_NAME}
  affiliation:
  - ${AFFILIATION}
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  rmdformats::downcute:
    highlight: textmate
    code_folding: hide
    toc_depth: 3
    css: custom.css
---

```{r setup_knitr, include=FALSE}
library('BiocStyle')
knitr::opts_chunk$set(
  autodep=TRUE, cache=TRUE, cache.lazy=FALSE, dev='png', warnings = FALSE, message = FALSE, 
  fig.path = "figure/${SHORT_TAG}_multiplexing.Rmd/"
  )
knitr::opts_knit$set(root.dir = '..', base.dir = '../public/', base.url = '')
```

```{r setup_helpers, message=FALSE, cache=FALSE, include = FALSE}
source('code/utils.R')
source('code/ambient.R')
source('code/multiplexing.R')
```

```{r get_samples, include = FALSE}
# get all sample ids
s_lvls    =  "${RUNS_STR}" %>%
  str_split(pattern = ',') %>% unlist()

```

```{r setup_input, include = FALSE}

# project metadata
proj_meta_f = "${METADATA_F}"


# files with barcode ranks and ambient parameters
af_dir      = "${af_dir}"
demux_dir   = "${demux_dir}"
sample_var  = "${SAMPLE_VAR}"

hto_smpl_dirs = sprintf(paste0(af_dir,'/', 'af_%s', '/hto' ), s_lvls)

# find hto knees
hto_knee_fs = sapply(
  hto_smpl_dirs,
  function(d) list.files(d, pattern = 'knee_plot_data_(.+)_.*.txt.gz.*', recursive = FALSE, full.names = TRUE)
) %>%
setNames(s_lvls)

assert_that( length(hto_knee_fs) > 0)
assert_that( all(file.exists(hto_knee_fs)))

# hto sce
hto_sce_fs = sapply(
  s_lvls, 
  function(s) list.files(demux_dir, pattern = sprintf('sce_cells_htos_%s.*', s), recursive = FALSE, full.names = TRUE)
) %>%
setNames(s_lvls)

assert_that( length(hto_sce_fs) > 0) 

```

```{r load_hto_knee_dfs, include = FALSE}
hto_knee_dfs = lapply(hto_knee_fs, FUN = fread)
```

```{r load_hto_sce, include = FALSE}
hto_sce_ls = lapply(hto_sce_fs, FUN = readRDS)
```

```{r load_meta, include=FALSE}
proj_meta = fread(proj_meta_f)
```

```{r get_hto_knee_params, include = FALSE}
hto_knee_params_df = lapply(hto_knee_dfs, FUN = get_knee_params, sample_var = sample_var) %>% rbindlist()
```

```{r get_hto_dt, include = FALSE}
pool_ids   = unique(proj_meta$pool_id)
sample_ids = unique(proj_meta$sample_id)
hto_dt_ls  = lapply(hto_sce_ls, FUN = get_hto_dt)
```


```{r arrange_samples_for_hto_qc_plots, include = FALSE}

# get total sample number
sample_n = nrow(hto_knee_params_df)

# arrange samples into groups of 12 acoording to their slope ratio
slope_ratio_ordered_samples = hto_knee_params_df %>%
  .[order(-slope_ratio)] %>%
  .[, get(sample_var)]

# arrange samples into groups of 12 according to their expected cells vs total included ratio
exp_tot_ratio_orderd_samples = hto_knee_params_df %>%
  .[order(-expected_total_ratio)] %>%
  .[, get(sample_var)]

# split long vector into subsets
n_per_plot  = 12
num_subsets = ceiling(sample_n/n_per_plot)
index_vec_for_split = rep(1:num_subsets, each = n_per_plot, length.out = sample_n)

# split sample_id vec into a list of subvectors
slope_ratio_split_l = split(slope_ratio_ordered_samples, index_vec_for_split)
exp_tot_ratio_split_l = split(exp_tot_ratio_orderd_samples, index_vec_for_split)
```

```{r get_knee_plot_dims, include = FALSE}

# set defaults
knee_width = 12
knee_height = 8

if(sample_n <= 4){
  knee_height = ceiling(8 * 1/3)
  knee_width = ceiling(12 * sample_n/4)
}else if(sample_n > 4 & sample_n <= 8){
  knee_height = ceiling(8* 2/3)
}

```

## Barcode rank plots

For each sample, barcodes are ranked in descending order based on their library size (number of unique molecular identifiers).
Typically, one can observe two plateaus in the barcode-rank curve: the first corresponds to droplets containing cells with high RNA content, while the second represents empty droplets containing ambient RNA.
Key transition points on the curve (inflection and knee points), are annotated with horizontal lines.
Two main parameters infered by `scprocess` based on transition points are `expected_cells` and `empty_plateau_middle`.
`empty_plateau_middleâ€˜ should extend a few thousand barcodes into the second plateau.
The absence of a clear empty plateau indicates poor sample quality due to ambient RNA contamination.

### Barcode rank plots ordered by slope ratio{.tabset}

The slope ratio helps identify low-quality samples with high ambient RNA contamination.
This ratio is calculated by dividing the slope of the barcode-rank curve in the empty droplet plateau by the slope at the first inflection point.
Samples are ordered from highest to lowest based on the slope ratio.

```{r hto_knee_plots_slope_ordered, fig.height = knee_height, fig.width = knee_width, results='asis'}
for (i in 1:length(slope_ratio_split_l) ) {
  # get knee dfs for all selected samples
  samples = slope_ratio_split_l[[i]]
  name = sprintf('sample chunk #%d', i)
  knees = hto_knee_dfs[samples]
  cat('#### ', name, '\n')
  print(plot_barcode_ranks_w_params(knees, hto_knee_params_df, sample_var = sample_var, bender_priors_df = NULL))
  cat('\n\n')
}
```

### Barcode rank plots ordered by `expected_cells`/`empty_plateau_middle` ratio{.tabset}

Inaccurate detection of the transition points (knee and inflection points) in the barcode-rank curve can lead to incorrect estimates of barcodes corresponding to cells or empty droplets.
To evaluate this, samples are ordered by the ratio of `expected_cells` to `empty_plateau_middle`.


```{r hto_knee_plots_exp_tot_ordered, fig.height = knee_height, fig.width = knee_width, results='asis'}
for (i in 1:length(exp_tot_ratio_split_l)) {
  # get knee dfs for all selected samples
  samples = exp_tot_ratio_split_l[[i]]
  name = sprintf('sample chunk #%d', i)
  knees = hto_knee_dfs[samples]
  cat('#### ', name, '\n')
  print(plot_barcode_ranks_w_params(knees, hto_knee_params_df, sample_var = sample_var, bender_priors_df = NULL))
  cat('\n\n')
}
```

## Dotplot with slope ratio and `expected_cells`/`empty_plateau_middle`

Both the slope ratio and the expected cells/total droplets ratio are displayed in a dot plot, where each dot represents a sample.
Outliers are labeled with their corresponding `sample_id` values.

```{r hto_params_qc_dot}
print(make_amb_params_dotplot(hto_knee_params_df, sample_var = sample_var, scales = 'free'))
```

## Table with global demultiplexing results
```{r demux_out_tbl}
rbindlist(hto_dt_ls) %>%
  .[, .(pool_id, class = HTO_classification.global)] %>%
  .[, count := .N, by = .(pool_id, class) ] %>%
  unique() %>%
  dcast(pool_id ~ class) %>%
  knitr::kable()
```

## Distribution of HTOs within a pool per sample{.tabset}

```{r hto_ridges_plot, results ='asis'}
for (i in sample_ids){
  cat('### ', i, '\n')
  print(hto_ridges(i, proj_meta = proj_meta, hto_dt_ls = hto_dt_ls))
  cat('\n\n')
}

```

## Pairs of HTO signals to confirm mutual exclusivity{.tabset}

```{r hto_pairwise plot, results = 'asis'}
for (i in pool_ids){
  pool_dt_tmp = hto_dt_ls[[i]]
  cat('### ', i, '\n')
  print(hto_pairwise(pool_dt = pool_dt_tmp, var = "norm_count"))
  cat('\n\n')
}
```
