---
title: "Marker genes"
author:
- name: ${YOUR_NAME}
  affiliation: 
  - ${AFFILIATION}
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  workflowr::wflow_html:
    code_folding: hide
    toc: true
    toc_float: true
    number_sections: false
---


```{r setup_knitr, include=FALSE}
library('BiocStyle')
knitr::opts_chunk$set( autodep=TRUE, cache=TRUE, cache.lazy=FALSE, dev='png' )
knitr::opts_knit$set( root.dir='..' )
# workflowr::wflow_build(files='analysis/${SHORT_TAG}_marker_genes_${MKR_SEL_RES}.Rmd', view=F, verbose=T, delete_cache=F)
```


```{r setup_helpers, message=FALSE, cache=FALSE, include = FALSE}
source('code/utils.R')
source('code/integration.R')
source('code/marker_genes.R')
library(stringi)
n_cores     = ${threads}
setDTthreads(n_cores)
```


```{r setup_input, include = FALSE}
# define files for calculating pseudobulk marker genes
meta_f        = "${meta_f}"
gtf_dt_f      = "${gtf_dt_f}"
pb_f          = "${pb_f}"
hmny_f        = "${hmny_f}"
mkrs_f        = "${mkrs_f}"
canon_f       = "${canon_f}"
hvgs_f        = "${hvgs_f}"

# fgsea files
fgsea_go_bp_f = "${fgsea_go_bp_f}"
fgsea_go_cc_f = "${fgsea_go_cc_f}"
fgsea_go_mf_f = "${fgsea_go_mf_f}"
fgsea_paths_f = "${fgsea_paths_f}"
fgsea_hlmk_f  = "${fgsea_hlmk_f}"

# parameters for here
not_ok_re     = "${MKR_NOT_OK_RE}"
exc_regex     = "${INT_EXC_REGEX}"
sel_res       = ${MKR_SEL_RES}
min_cpm_mkr   = ${MKR_MIN_CPM_MKR}
min_cells     = ${MKR_MIN_CELLS}

# parameters for FGSEA
gsea_cut      = ${MKR_GSEA_CUT}

# define nice order for plotting
cl_ord        = NULL

# define metadata variables for plotting
metadata_vars = "${meta_vars_ls}" %>% 
  str_split(pattern = ",") %>% unlist()
if (all(metadata_vars == ""))
  metadata_vars = NULL

# combine metadata variables for plot description
metadata_txt = paste(metadata_vars, collapse = ', ') %>%
stri_replace_last_fixed(",", " and")
```

```{r load_metadata, include = FALSE}
meta_dt       = meta_f %>% fread
if(!is.null(metadata_vars)){
assert_that( all(metadata_vars %in% names(meta_dt)) )
}
```

```{r load_harmony_clusters, include = FALSE}
harmony_dt    = fread(hmny_f) %>% .[ !is.na(UMAP1) ] %>% 
  .[, c("sample_id", "cell_id", "integration", "UMAP1", "UMAP2", 
    str_subset(names(.), "RNA_snn_res")), with = FALSE] %>% 
  .[, cluster := get(paste0("RNA_snn_res.", sel_res))]
hmny_dt       = harmony_dt[, .(sample_id, cell_id, UMAP1, UMAP2, cluster)] %>% 
  merge(meta_dt, by = "sample_id")
```

```{r load_gene_biotypes, include = FALSE}
biotypes_dt   = load_gene_biotypes(gtf_dt_f)
```

```{r load_cpms, include = FALSE}
cpms_dt     = readRDS(pb_f) %>% 
  make_logcpms_all(lib_size_method = "edger", 
    exc_regex = exc_regex, min_cells = min_cells, n_cores = n_cores) %>% 
  merge(biotypes_dt[, .(gene_id, gene_type)], by = "gene_id")
```

```{r load_hvgs, include = FALSE}
hvgs_dt     = fread(hvgs_f) %>% 
  .[ str_detect(gene_type, not_ok_re, negate = TRUE) ] %>% 
  .[ order(-vst_var) ]
```


```{r load_heatmap_markers, include = FALSE}
canon_dt    = fread(canon_f) %>% 
  .[, gene_id   := sprintf("%s_%s", symbol, ensembl_id) ]
assert_that( all( canon_dt$gene_id %in% unique(cpms_dt$gene_id) ) )
top_hvgs    = hvgs_dt[ 1:50 ] %>% .[, geneset := "HVGs" ]
mkrs_ls     = list( brain = canon_dt, HVGs = top_hvgs )
```

```{r load_pb_markers, include = FALSE}
# calculate markers
mkrs_dt     = fread(mkrs_f)
if (is.null(cl_ord))
  cl_ord      = sort(unique(mkrs_dt$cluster))
```


```{r get_top_markers, include = FALSE}
# select top markers
top_dt      = mkrs_dt[ str_detect(gene_type, not_ok_re, negate = TRUE) ] %>% 
  get_top_markers
top_min_dt  = mkrs_dt[ str_detect(gene_type, not_ok_re, negate = TRUE) ] %>% 
  .[ logcpm.sel >= log(min_cpm_mkr + 1) ] %>% 
  get_top_markers
```

```{r calc_gsea_pb, include = FALSE}
# do GSEA
fgsea_fs        = c(fgsea_go_bp_f, fgsea_go_cc_f, fgsea_go_mf_f, fgsea_paths_f, fgsea_hlmk_f)
names(fgsea_fs) = str_extract(fgsea_fs, "(go_bp|go_cc|go_mf|paths|hlmk)")

# load fgsea results
gsea_ls         = lapply(fgsea_fs, fread) %>% setNames(names(fgsea_fs))
```


## Clusters over UMAP{.tabset}

Clustering of data is performed at resolution `r sel_res`. Cluster membership of cells is displayed on a UMAP.

```{r plot_harmony_clusters_sel_res, fig.height = 5, fig.width = 11}
g_cl    = plot_umap_cluster(
  umap_dt   = harmony_dt[, .(cell_id, UMAP1, UMAP2) ], 
  clust_dt  = harmony_dt[, .(cell_id, cluster = get(paste0('RNA_snn_res.', sel_res))) ],
  name      = sprintf('res = %s', sel_res))
g_dens  = plot_umap_density(harmony_dt[, .(cell_id, UMAP1, UMAP2) ])
g       = g_cl + g_dens
print(g)
```

## Cluster splits by metadata variables

For each cluster the proportion of cells coming from samples associated with specific values of `r metadata_txt` are shown. 

```{r plot_clusters_by_metadata, fig.height = 8, fig.width = 7}
if (!is.null(metadata_vars))
  (plot_clusters_by_metadata(meta_dt, harmony_dt, 
    meta_vars = metadata_vars, cl_order = cl_ord))
```

## Metadata variables over UMAP{.tabset}

The plot shows a binned UMAP with facets corresponding to specific values of `r if (length(metadata_vars) == 1) print(metadata_vars) else print("different metadata variables")` which allows the evaluation of whether cells sharing certain annotations are particularly abundant in some clusters/parts of the UMAP space or evenly distributed. 

```{r plot_metadata_over_UMAP, fig.height = 6, fig.width = 8, results = 'asis'}
for (meta_var in metadata_vars) {
  cat('###', meta_var, '\n')
  print(plot_clusters_annotated_by_densities(hmny_dt, meta_var))
  cat('\n\n')
}
```

## Marker genes

To identify marker genes for each cluster, pseudobulk counts are obtained for each sample/sample_id by aggregating the expression values from all cells belonging to a specific cluster.
Similarly, we aggregate the expression values from all cells in the remaining clusters. The resulting pseudobulk values for the target cluster are then compared to those of the remaining clusters using edgeR.

### Heatmaps of marker genes{.tabset}

The resulting log 2 fold change values (calculated using edgeR) per cluster are shown for X highly variable genes and selected canonical marker genes.

```{r plot_canonical_markers_heatmap, fig.height = 9, fig.width = 10, results = 'asis'}
for (nn in names(mkrs_ls)) {
  cat("#### ", nn, "\n")
  draw( plot_heatmap_of_selected_genes(mkrs_dt, mkrs_ls[[nn]]),
    heatmap_legend_side = "bottom", annotation_legend_side = "bottom", merge_legend = TRUE )
  cat("\n\n")
}
```

### Highly variable genes{.tabset}

Normalized pseudobulk expression values for top 100? highly variable genes are shown for each cluster

```{r plot_hvgs_pb_hmny, fig.height = 8, fig.width = 8, results = "asis"}
n_pages = 10
per_p   = 10
p       = 1
for (i in seq(1, n_pages * per_p, by = per_p)) {
  cat('#### page', p, '\n'); p = p + 1
  sel_hvgs  = hvgs_dt[ i:(i + 9) ]
  print(plot_selected_genes(sel_hvgs, cpms_dt, cl_order = cl_ord))
  cat('\n\n')
}
```

### Top marker genes (min expression){.tabset}

Normalized pseudobulk expression values of top 100? marker genes with a minimum expression of `r min_cpm_mkr` CPM and FDR < 0.05 are shown for each cluster. 


```{r plot_top_markers_pb_min, fig.height = 8, fig.width = 8, results = "asis"}
for (sel_cl in cl_ord) {
  cat('####', sel_cl, '\n')
  print(plot_top_marker_genes(sel_cl, top_min_dt, cpms_dt, cl_order = cl_ord))
  cat('\n\n')
}
```

### Top marker genes{.tabset}

Normalized pseudobulk expression values of top 100? marker genes with FDR < 0.05 are shown for each cluster. 

```{r plot_top_markers_pb, fig.height = 8, fig.width = 8, results = "asis"}
for (sel_cl in cl_ord) {
  cat('####', sel_cl, '\n')
  print(plot_top_marker_genes(sel_cl, top_dt, cpms_dt, cl_order = cl_ord))
  cat('\n\n')
}
```

## GSEA characterisation of `harmony` clusters{.tabset}

GSEA was performed on marker genes for each cluster, using logFC as the ranking variable. Top x pathways grouped into 5 categories with (some threshold) are shown for each cluster.

```{r plot_gsea_results_pb, fig.height = 12, fig.width = 8, results = "asis"}
for (p in names(gsea_ls)) {
  cat('### ', p, '\n')
  dt    = gsea_ls[[p]] %>% .[ gsea_var == "z_score" ]
  plot_gsea_dotplot(dt, gsea_cut = gsea_cut, n_top_paths = 5, max_nes = 2,
    size_range = c(10, 200), what = "pos_only", cl_order = cl_ord) %>% print
  cat('\n\n')
}
```
