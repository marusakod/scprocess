---
title: "Cell type labelling with XGBoost"
author:
- name: ${your_name}
  affiliation: 
  - ${affiliation}
date: '`r format(as.Date("${date_stamp}"), "%B %d, %Y")`'
output:
  rmdformats::downcute:
    highlight: textmate
    code_folding: hide
    toc_depth: 3
    css: custom.css
---


```{r setup_knitr, include=FALSE}
library('BiocStyle')
knitr::opts_chunk$set( autodep=TRUE, cache=TRUE, cache.lazy=FALSE, dev='png', 
fig.path = "figure/${short_tag}_label_celltypes.Rmd/"
)

knitr::opts_knit$set(root.dir = '..', base.dir = '../public/', base.url = '')

```


```{r setup_helpers, message=FALSE, cache=FALSE, include = FALSE}
source('code/utils.R')
source('code/integration.R')
source('code/label_celltypes.R')
n_cores       = ${threads}
setDTthreads(n_cores)
```


```{r setup_input, include = FALSE}
# input_files
int_f           = "${int_f}"
guess_f_ls      = str_split("${guess_f_ls}", " ")[[ 1 ]]
labeller_ls     = str_split("${labeller_ls}", " ")[[ 1 ]]
model_ls        = str_split("${model_ls}", " ")[[ 1 ]]

# params
hi_res_cl_ls    = str_split("${hi_res_cl_ls}", " ")[[ 1 ]]
min_cl_prop_ls  = str_split("${min_cl_prop_ls}", " ")[[ 1 ]] %>% as.numeric
min_cl_size_ls  = str_split("${min_cl_size_ls}", " ")[[ 1 ]] %>% as.numeric
```

```{r load_umap, include = FALSE}
int_dt        = fread(int_f) %>% .[ (is_dbl == FALSE) & (in_dbl_cl == FALSE) ]
```

```{r load_guesses, include = FALSE}
# get predictions
assert_that( all(sapply(guess_f_ls, file.exists)) )
guesses_ls    = lapply(guess_f_ls, fread) %>% setNames(model_ls)
```

## Integration clusters vs predicted cell types{.tabset}

<!-- Prediction of cell type labels is a two-step process: The XGBoost classifier first assigns a predicted cell type to each individual cell.
These cell-level predictions are then aggregated at the cluster level (a majority-voting approach is used, where the final, assigned label for a
cluster is the most common predicted label among all the cells within it).

The heatmap helps to asses whether cell-level predictions are consistent with clustering results at different resolutions.
Each cell on the heatmap shows the proportion of cells within a cluster (on the x-axis) that are assigned a specific predicted cell type (on the y-axis).
By examining these results, clustering resolution that provides the most reliable labels for the final, cluster-level prediction step can be selected.
 -->

```{r plot_cls_vs_pred, fig.height = 12, fig.width = 13, results = 'asis'}
for (ii in seq_along(guess_f_ls)) {
  # unpack
  this_labeller   = labeller_ls[[ ii ]]
  this_model      = model_ls[[ ii ]]
  this_hi_res_cl  = hi_res_cl_ls[[ ii ]]

  # make confusion matrix
  guesses_sel = guesses_ls[[ ii ]] %>% 
    .[, .(cell_id, prediction = predicted_label_naive %>% factor)]
  int_tmp     = int_dt[, .(cell_id, UMAP1, UMAP2, hi_res_cl = get(this_hi_res_cl) %>% fct_infreq)]
  confuse_dt  = calc_confuse_dt(guesses_sel, int_tmp, "prediction", "hi_res_cl")

  # plot heatmap
  cat('### ', this_labeller, ', ', this_model, '\n', sep = '')
  draw(plot_cluster_comparison_heatmap(confuse_dt, "prediction", this_hi_res_cl, 
    plot_var = 'log_p_cl2', do_sort = "hclust"), merge_legend = TRUE)
  cat('\n\n')
}
```

## Predicted cell types over UMAP{.tabset}

Clustering of data is performed at different resolution values. For each value the clusters are displayed over a UMAP together with a plot showing predicted cell type labels.

```{r plot_preds_over_umap, fig.height = 5, fig.width = 12, results = 'asis'}
for (ii in seq_along(guess_f_ls)) {
  # unpack
  this_labeller   = labeller_ls[[ ii ]]
  this_model      = model_ls[[ ii ]]
  this_hi_res_cl  = hi_res_cl_ls[[ ii ]]

  # get data
  guesses_sel = guesses_ls[[ ii ]] %>% 
    .[, .(cell_id, prediction = predicted_label_agg %>% factor)]
  int_tmp     = int_dt[, .(cell_id, UMAP1, UMAP2, hi_res_cl = get(this_hi_res_cl) %>% fct_infreq)]

  # plots
  g_cl        = plot_umap_cluster(int_dt, 
    int_tmp[, .(cell_id, cluster = hi_res_cl)], "high resolution\nharmony\ncluster")
  g_pred      = plot_umap_cluster(int_dt, 
    guesses_sel[, .(cell_id, cluster = prediction)], "prediction\n(aggregated)")
  g = g_cl + g_pred

  # plot umaps
  cat('### ', this_labeller, ', ', this_model, '\n', sep = '')
  print(g)
  cat('\n\n')
}
```

## R session info

Details of the R package versions used are given below.

<details>
```{r session_info, include=TRUE, echo=TRUE, results="markup"}
devtools::session_info()
```
</details>
