---
title: "Cell type labelling with XGBoost"
author:
- name: ${your_name}
  affiliation: 
  - ${affiliation}
date: '`r format(as.Date("${date_stamp}"), "%B %d, %Y")`'
output:
  rmdformats::downcute:
    highlight: textmate
    code_folding: hide
    toc_depth: 3
    css: custom.css
---


```{r setup_knitr, include=FALSE}
library('BiocStyle')
knitr::opts_chunk$set( autodep=TRUE, cache=TRUE, cache.lazy=FALSE, dev='png', 
fig.path = "figure/${short_tag}_label_celltypes.Rmd/"
)

knitr::opts_knit$set(root.dir = '..', base.dir = '../public/', base.url = '')

```


```{r setup_helpers, message=FALSE, cache=FALSE, include = FALSE}
source('code/utils.R')
source('code/integration.R')
source('code/label_celltypes.R')
n_cores       = ${threads}
setDTthreads(n_cores)
```


```{r setup_input, include = FALSE}
# input_files
int_f         = "${int_f}"
guesses_fs    = str_split("${guesses_fs}", " ")[[ 1 ]]
models        = str_split("${lbl_models}", " ")[[ 1 ]]

# params
hi_res_cl     = "${lbl_hi_res_cl}"
min_cl_prop   = ${lbl_min_cl_prop}
min_cl_size   = ${lbl_min_cl_size}
```

```{r load_umap, include = FALSE}
int_dt        = fread(int_f) %>% .[ (is_dbl == FALSE) & (in_dbl_cl == FALSE) ] %>% 
  .[, .(cell_id, UMAP1, UMAP2, hi_res_cl = get(hi_res_cl) %>% fct_infreq)]
```

```{r load_guesses, include = FALSE}
# get predictions
assert_that( all(sapply(guesses_fs, file.exists)) )
guesses_ls    = lapply(guesses_fs, fread) %>% setNames(models)
```

## Integration clusters vs predicted cell types{.tabset}

<!-- Prediction of cell type labels is a two-step process: The XGBoost classifier first assigns a predicted cell type to each individual cell.
These cell-level predictions are then aggregated at the cluster level (a majority-voting approach is used, where the final, assigned label for a
cluster is the most common predicted label among all the cells within it).

The heatmap helps to asses whether cell-level predictions are consistent with clustering results at different resolutions.
Each cell on the heatmap shows the proportion of cells within a cluster (on the x-axis) that are assigned a specific predicted cell type (on the y-axis).
By examining these results, clustering resolution that provides the most reliable labels for the final, cluster-level prediction step can be selected.
 -->

```{r plot_cls_vs_pred, fig.height = 12, fig.width = 13, results = 'asis'}
for (model in models) {
  # make confusion matrix
  guesses_sel = guesses_ls[[ model ]] %>% .[, .(cell_id, prediction = predicted_label_naive %>% factor)]
  confuse_dt  = calc_confuse_dt(guesses_sel, int_dt, "prediction", "hi_res_cl")

  # plot heatmap
  cat('### ', model, '\n', sep = '')
  draw(plot_cluster_comparison_heatmap(confuse_dt, "prediction", hi_res_cl, 
    plot_var = 'log_p_cl2', do_sort = "hclust"), merge_legend = TRUE)
  cat('\n\n')
}
```

## Predicted cell types over UMAP{.tabset}

Clustering of data is performed at different resolution values. For each value the clusters are displayed over a UMAP together with a plot showing predicted cell type labels.

```{r plot_preds_over_umap, fig.height = 5, fig.width = 12, results = 'asis'}
# plot
for (model in models) {
  # make confusion matrix
  guesses_sel = guesses_ls[[ model ]] %>% .[, .(cell_id, prediction = predicted_label_agg %>% factor)]
  g_cl        = plot_umap_cluster(int_dt, 
    int_dt[, .(cell_id, cluster = hi_res_cl)], "high resolution\nharmony\ncluster")
  g_pred      = plot_umap_cluster(int_dt, 
    guesses_sel[, .(cell_id, cluster = prediction)], "prediction\n(aggregated)")
  g = g_cl + g_pred

  # plot umaps
  cat('### ', model, '\n', sep = '')
  print(g)
  cat('\n\n')
}
```

## R session info

Details of the R package versions used are given below.

<details>
```{r session_info, include=TRUE, echo=TRUE, results="markup"}
devtools::session_info()
```
</details>
