---
title: "Cell-level QC"
author:
- name: ${YOUR_NAME}
  affiliation: 
  - ${AFFILIATION}
date: '`r format(as.Date("${DATE_STAMP}"), "%B %d, %Y")`'
output:
  rmdformats::downcute:
    highlight: textmate
    code_folding: hide
    toc_depth: 3
    css: custom.css
---

```{r setup_knitr, include=FALSE}
library('BiocStyle')
knitr::opts_chunk$set(
  autodep=TRUE, cache=TRUE, cache.lazy=FALSE, dev='png', 
  fig.path = "figure/${SHORT_TAG}_qc.Rmd/"
)
knitr::opts_knit$set(root.dir = '..', base.dir = '../public/', base.url = '')
# workflowr::wflow_build(files='analysis/${SHORT_TAG}_qc.Rmd', view=F, verbose=T, delete_cache=F)
```

```{r setup_helpers, message=FALSE, cache=FALSE, include = FALSE}
source('code/utils.R')
source('code/qc.R')
n_cores     = ${threads}
setDTthreads(n_cores)
```

```{r setup_input, include = FALSE}
# define qc metric files
meta_f      = "${meta_f}"
qc_f        = "${qc_dt_f}"

# set default values
hard_min_counts = ${QC_HARD_MIN_COUNTS}
hard_min_feats  = ${QC_HARD_MIN_FEATS}
hard_max_mito   = ${QC_HARD_MAX_MITO}
min_counts      = ${QC_MIN_COUNTS}
min_feats       = ${QC_MIN_FEATS}
min_mito        = ${QC_MIN_MITO}
max_mito        = ${QC_MAX_MITO}
min_splice      = ${QC_MIN_SPLICE}
max_splice      = ${QC_MAX_SPLICE}
min_cells       = ${QC_MIN_CELLS}

# specifications for SampleQC
qc_names    = c('log_counts', 'log_feats', 'logit_mito', 'logit_spliced')
qc_lu       = c('no. of UMIs', 'no. of genes', 'mito. pct.', 'spliced pct.') %>% 
  setNames(qc_names)
```

```{r load_qc_values, include = FALSE}
qc_dt       = fread(qc_f) %>% 
  .[ log_counts > log10(hard_min_counts) ] %>% 
  .[ log_feats  > log10(hard_min_feats) ] %>% 
  .[ logit_mito < qlogis(hard_max_mito) ]
kept_dt     = qc_dt[ keep == TRUE ]
```

```{r load_metadata, include = FALSE}
# get nice ordering for samples
meta_dt     = fread(meta_f)
s_lvls      = meta_dt$sample_id %>% intersect(unique(qc_dt$sample_id))
n_samples   = length(s_lvls)
```

```{r make_threshold_dt, include = FALSE}
thrshlds_ls = list(
  log_counts    = log10(min_counts),
  log_feats     = log10(min_feats),
  logit_mito    = c(qlogis(min_mito), qlogis(max_mito)),
  logit_spliced = c(qlogis(min_splice), qlogis(max_splice))
)
thrshlds_dt = lapply(names(thrshlds_ls), function(nn) {
  data.table( qc_var = nn, cut_point = thrshlds_ls[[ nn ]] )
  }) %>% rbindlist
thrshlds_dt = thrshlds_dt[ !is.infinite(cut_point) ]
```

```{r setup_plot_sizes, include = FALSE}
violin_h    = 0.5
max_marg_h  = 12
marg_h      = min((n_samples + 1) * violin_h, max_marg_h)
```

## Sample QC metrics{.tabset}

An overview of quality control (QC) metrics for all samples, both before and after filtering. The QC metrics include:

* `no. of cells` : Total number of barcodes called as cells for each sample. Samples with less than `r min_cells` cells are excluded from further analysis.

* `no. of UMIs` : Sum of counts across all features for each cell with log-transformed values displayed. Barcodes with fewer than `r min_counts` UMIs are excluded from further analysis.

* `no. of genes` : Number of unique features with non-zero counts for each cell with log-transformed values displayed. Barcodes with fewer than `r min_feats` unique genes are excluded from further analysis.

* `mito pct.` : The proportion of reads that mapped to genes in the mitochondrial genome. High proportions are indicative of poor-quality cells (compromised membranes allow individual RNA molecules to escape while retaining mitochondria,
leading to an increased relative abundance of mitochondrial transcript) or nuclei (incomplete removal of cytoplasm). Logit-transformed values are displayed as applying the logit (inverse logistic) transformation to mitochondrial proportions yields approximately Gaussian distributions. Barcodes with mitochondrial proportions exceeding `r max_mito*100`% are excluded from further analysis. 

* `spliced pct.` : The proportion of spliced reads. In single-nuclei RNA sequencing, high spliced proportions may indicate inadequate removal of cytoplasmic material from the nuclei.
Logit-transformed values are displayed as applying the logit  (inverse logistic) transformation to spliced proportions results in approximately Gaussian distributions.
Barcodes with spliced proportions greater than `r max_splice*100`% are excluded from further analysis. 


```{r plot_qc_ranges_marginals, fig.height = marg_h, fig.width = 8, results = 'asis'}
suppressWarnings({
  cat("### Pre-QC\n")
  print(plot_qc_ranges_marginals(qc_dt, s_lvls, qc_names, qc_lu, thrshlds_dt))
  cat("\n\n")
  cat("### After light QC\n")
  print(plot_qc_ranges_marginals(kept_dt, s_lvls, qc_names, qc_lu, thrshlds_dt))
  cat("\n\n")
})
```

## QC metrics scatterplots{.tabset}

Pairwise relationships of QC metrics at individual cell level.

```{r plot_qc_metric_scatters, fig.height = 6, fig.width = 8, results = 'asis'}
for (s in s_lvls) {
  qc_tmp      = qc_dt[ sample_id == s ]
  if (nrow(qc_tmp) == 1)
    next
  cat('### ', s, '\n')
  print(plot_qc_metric_scatter(qc_tmp, qc_names, qc_lu, thrshlds_dt))
  cat('\n\n')
}
```

## How many cells and samples retained?

Table summarizing the number of cells before and after qc filtering. Some samples 
may have been excluded from further analysis due to insufficient number of cells.

```{r print_totals_excluded}
calc_qc_summary(qc_dt, kept_dt, thrshlds_ls, qc_lu) %>% knitr::kable()
```

## What were the reasons for excluding barcodes?{.tabset}

An upset plot is generated for each sample to visualize the reasons for barcode exclusion. The plot shows the overlap between different exclusion criteria, with vertical bars representing the size of each intersection. Plots are omitted for samples where no barcodes were excluded.

```{r plot_upsets_of_exclusions, fig.height = 5, fig.width = 7, results = 'asis'}
for (s in s_lvls) {
  qc_tmp      = qc_dt[ sample_id == s ]
  if (nrow(qc_tmp) == 1 | sum(qc_tmp$keep) == nrow(qc_tmp))
    next
  cat('### ', s, '\n')
  suppressMessages( print(plot_upset_of_exclusions(qc_tmp, qc_names, qc_lu, thrshlds_ls)) )
  cat('\n\n')
}
```

## R session info

Details of the R package versions used are given below.

<details>
```{r session_info, include=TRUE, echo=TRUE, results="markup"}
devtools::session_info()
```
</details>
