---
title: "Zoom in and recluster: ${zoom_name}"
author:
- name: ${YOUR_NAME}
  affiliation:
  - ${AFFILIATION}
date: '`r format(as.Date("${DATE_STAMP}"), "%B %d, %Y")`'
output:
  rmdformats::downcute:
    highlight: textmate
    code_folding: hide
    toc_depth: 3
    css: custom.css
---


```{r setup_knitr, include=FALSE}
library('BiocStyle')
knitr::opts_chunk$set( autodep=TRUE, cache=TRUE, cache.lazy=FALSE, dev='png', warnings = FALSE, 
  fig.path = "figure/${SHORT_TAG}_zoom_${zoom_name}.Rmd/")
knitr::opts_knit$set(root.dir = '..', base.dir = '../public/', base.url = '')

```


```{r setup_helpers, message=FALSE, cache=FALSE, include = FALSE}
source('code/utils.R')
source('code/integration.R')
source('code/marker_genes.R')
source('code/hvgs.R')
library(stringi)
n_cores = ${threads}
setDTthreads(n_cores)
```


```{r setup_input, include = FALSE}
# define selected group
zoom_dir      = "${zoom_dir}"
zoom_name     = "${zoom_name}"
sub_dir       = file.path(zoom_dir, zoom_name)

# define files for calculating pseudobulk marker genes
meta_f        = "${meta_f}"
gtf_dt_f      = "${gtf_dt_f}"
qc_f          = "${qc_f}"
int_f         = "${int_f}"
pb_f          = "${pb_f}"
mkrs_f        = "${mkrs_f}"
mkrs_hvgs_f   = "${mkrs_hvgs_f}"
hvgs_f        = "${hvgs_f}"
empty_gs_f    = "${empty_gs_f}"
pb_empty_f    = "${pb_empty_f}"

# fgsea files
fgsea_go_bp_f = "${fgsea_go_bp_f}"
fgsea_go_cc_f = "${fgsea_go_cc_f}"
fgsea_go_mf_f = "${fgsea_go_mf_f}"
fgsea_paths_f = "${fgsea_paths_f}"
fgsea_hlmk_f  = "${fgsea_hlmk_f}"

# custom markers for heatmap
custom_mkr_names_str = "${CUSTOM_MKR_NAMES}"
custom_mkr_paths_str = "${CUSTOM_MKR_PATHS}"

if(custom_mkr_names_str != ""){
  custom_mkr_names = str_split(custom_mkr_names_str, pattern = ',') %>% unlist()
  custom_mkr_paths = str_split(custom_mkr_paths_str, pattern = ',') %>% unlist() %>%
    setNames(custom_mkr_names)
}

# define QC lookups
qc_names    = c('log_counts', 'log_feats', 'logit_mito', 'logit_spliced')
qc_lu       = c('library size', 'no. of features', 'mito pct.', 'spliced pct.') %>% 
  setNames(qc_names)

# integration/clustering parameters
res_ls  = "${INT_RES_LS}" %>%
 str_split(pattern = ' ') %>% unlist() %>% as.numeric()  

# marker parameters
not_ok_re     = "${MKR_NOT_OK_RE}"
sel_res       = "${MKR_SEL_RES}"
min_cpm_mkr   = ${MKR_MIN_CPM_MKR}
min_cells     = ${MKR_MIN_CELLS}

# parameters for gsea
gsea_cut      = ${MKR_GSEA_CUT}
species       = "${SPECIES}"

# define nice order for plotting
cl_ord        = NULL

# define metadata variables for plotting
metadata_vars = "${meta_vars_ls}" %>% 
  str_split(pattern = ",") %>% unlist()
if (all(metadata_vars == ""))
  metadata_vars = NULL

# combine metadata variables for plot description
metadata_txt = paste(metadata_vars, collapse = ', ') %>%
stri_replace_last_fixed(",", " and")
```

```{r load_metadata, include = FALSE}
meta_dt       = meta_f %>% fread
if(!is.null(metadata_vars)){
  assert_that( all(metadata_vars %in% names(meta_dt)) )
}
```

```{r load_hvg_data, include = FALSE}
hvgs_dt     = fread(hvgs_f)
edger_dt    = fread(empty_gs_f)
pb          = readRDS(pb_empty_f)
```

```{r extract_integration_res, include = FALSE}
integration_all = fread(int_f)
int_dt    = integration_all[ !is.na(UMAP1) ] %>% 
  .[, c("sample_id", "cell_id", "reduction", "UMAP1", "UMAP2", 
    str_subset(names(integration_all), "RNA_snn_res")), with = FALSE]
```

```{r extract_sel_cls, include = FALSE}
sel_cl_int_dt = copy(int_dt) %>%
.[, cluster := get(paste0("RNA_snn_res.", sel_res))] %>%
.[, .(sample_id, cell_id, UMAP1, UMAP2, cluster)] %>% 
merge(meta_dt, by = "sample_id")
```

```{r load_qc_results, include = FALSE}
qc_melt     = fread(qc_f) %>% 
  .[ cell_id %in% int_dt$cell_id ] %>% 
  melt(id = 'cell_id', measure = qc_names, val = 'qc_val', var = 'qc_var') %>%
  .[, qc_full := qc_lu[ qc_var ] ] %>%
  .[, qc_var  := factor(qc_var, levels = qc_names) ] %>%
  .[, qc_full := fct_reorder(qc_full, as.integer(qc_var)) ] %>% 
  .[ !is.na(qc_val) ]
```

```{r load_gene_biotypes, include = FALSE}
biotypes_dt   = load_gene_biotypes(gtf_dt_f)
```

```{r load_cpms, include = FALSE}
cpms_dt     = readRDS(pb_f) %>% 
  make_logcpms_all(lib_size_method = "edger", 
    min_cells = min_cells, n_cores = n_cores) %>% 
  merge(biotypes_dt[, .(gene_id, gene_type)], by = "gene_id")
```

```{r load_mkr_hvgs, include = FALSE}
mkrs_hvgs_dt     = fread(mkrs_hvgs_f) %>% 
  .[ str_detect(gene_type, not_ok_re, negate = TRUE) ] %>% 
  .[ order(-vst_var) ]
top_hvgs =  mkrs_hvgs_dt[ 1:50 ] %>% .[, geneset := "HVGs" ]
```

```{r load_mkr_ambient_genes, include = FALSE}
ambient_dt  = fread(empty_gs_f ) %>% 
  merge(biotypes_dt, by = "gene_id") %>% 
  .[ str_detect(gene_type, not_ok_re, negate = TRUE) ] %>% 
  .[ (logFC > 0) & (mean_logcpm.empties > log(min_cpm_mkr + 1)) ] %>% 
  .[ order(PValue) ] %>% 
  .[ gene_id %in% unique(cpms_dt$gene_id) ]
ambient_gs  = ambient_dt[ 1:50 ] %>% .[, .(gene_id, symbol, vst_var = NA)] %>% 
  .[, geneset := "ambient" ]
```

```{r load_pb_markers, include = FALSE}
# calculate markers
mkrs_dt     = fread(mkrs_f)
if (is.null(cl_ord))
  cl_ord      = sort(unique(mkrs_dt$cluster))
```

```{r load_heatmap_markers, include = FALSE}
mkrs_ls   = list(HVGs = top_hvgs, ambient = ambient_gs)
if (custom_mkr_names_str != "") {
  custom_mkrs_dt_ls = lapply(custom_mkr_paths, FUN = process_custom_markers, 
    biotypes_dt = biotypes_dt, hvgs_dt = mkrs_hvgs_dt, marker_calcs_dt = mkrs_dt)
  
  # remove NULL elements from list
  custom_mkrs_dt_ls = Filter(Negate(is.null), custom_mkrs_dt_ls)
  
  mkrs_ls = c(custom_mkrs_dt_ls, mkrs_list)
} 
```

```{r calc_empty_hvgs, include = FALSE}
vst_obj     = calc_vst_obj(pb, edger_dt)
```

```{r get_top_markers, include = FALSE}
# select top markers
top_dt      = mkrs_dt[ str_detect(gene_type, not_ok_re, negate = TRUE) ] %>% 
  get_top_markers
top_min_dt  = mkrs_dt[ str_detect(gene_type, not_ok_re, negate = TRUE) ] %>% 
  .[ logcpm.sel >= log(min_cpm_mkr + 1) ] %>% 
  get_top_markers
```

```{r calc_gsea_pb, include = FALSE}
# do GSEA
fgsea_fs      = c(fgsea_go_bp_f, fgsea_go_cc_f, fgsea_go_mf_f, fgsea_paths_f, fgsea_hlmk_f) %>% 
  setNames(c("go_bp", "go_cc", "go_mf", "paths", "hlmk"))

# load fgsea results
gsea_ls       = lapply(fgsea_fs, function(f) if(file.exists(f)) {fread(f)} else {return(NULL)}) %>% setNames(names(fgsea_fs))
```


```{r plot_setup, include = FALSE}
do_metadata   = length(metadata_vars) > 0
do_gsea       = species %in% c('human_2024', 'human_2020', 'mouse_2024', 'mouse_2020')
```

## HVG selection diagnostics

The selection of highly variable genes is a crucial step in the integration process and in
identifying clusters in single-cell experiments. However, contamination from ambient RNA can act as a
significant confounding factor. This section of the report provides plots to evaluate the influence of ambient RNA on the selection
of highly variable genes and its potential impact on downstream analyses.

### Are highly variable genes "ambient" ?

The plot shows the extent to which highly variable genes identified using the `Seurat` VST method may
be influenced by ambient RNA. The x-axis represents the `log2fc` values derived from the ambient gene estimation
step in `scprocess` (see `scprocess` documentation for more details), while the y-axis shows the
trend-normalized variance calculated using the `Seurat` VST method. Each point represents a gene,
annotated based on whether it is among the top HVGs and whether it is identified as ambient by the
ambient gene detection step. Labelled genes are top 10 most variable.

```{r plot_std_var_vs_empty_log2fc, fig.height = 6, fig.width = 8}
print(plot_hvg_stats_vs_empty_log2fc(hvgs_dt, edger_dt))
```

### Which genes are "ambient"?{.tabset}

The plot shows the results of the `scprocess` ambient gene detection procedure. The y-axis
is the `-log10` nominal p-value, with a dotted line indicating the threshold where the adjusted p-value
is sufficiently small (< 0.01). Multiple plots are shown, each corresponding to a different
minimum expression level filter applied to the ambient profiles.

```{r plot_ambient_gene_calculations, fig.height = 6, fig.width = 6, results = 'asis'}
cpm_ls  = c(100, 50, 10, 0)
for (min_cpm in cpm_ls) {
  if (min_cpm == 0) {
    cat("#### all genes\n")
  } else {
    cat(sprintf("#### >= %d CPM expression in ambient\n", min_cpm))
  }
  print(plot_ambient_gene_calculations(edger_dt, min_cpm_empty = min_cpm))
  cat("\n\n")
}
```

### Which genes are variable across the ambient profiles?{.tabset}

Examining how ambient genes vary across different samples can provide valuable insights.
Such variation may highlight cases where certain samples require distinct treatment, for example,
if case and control samples consistently exhibit different ambient profiles.

The heatmaps display the pseudobulk expression of various genes across the ambient profiles of each sample in the dataset.
The genes shown are the top 40 selected based on the following criteria:

- highest variance across ambient profiles;
- highest mean expression across ambient profiles;
- highest `log2fc` in empty droplets vs cells in `scprocess`'s ambient gene detection procedure; 
and
- smallest p-value in empty droplets vs cells in `scprocess`'s ambient gene detection procedure.

```{r plot_ambient_profiles, fig.height = 8, fig.width = 6, results = 'asis'}
title_ls = c(
  "var"           = "HVGs",
  "mean"          = "Highest expression",
  "log2fc.empty"  = "Highest log2fc",
  "pval.empty"    = "Smallest p-value"
)
for (top_var in names(title_ls)) {
  cat(sprintf("#### %s in ambient\n", title_ls[top_var]))
  suppressMessages(draw(plot_heatmap_of_ambient_profiles(vst_obj, top_var = top_var, 
    n_top = 40), heatmap_legend_side = "right", merge_legend = TRUE ))
  cat("\n\n")
}
```


## Clustering diagnostics

### Clusters over UMAP{.tabset}

Clustering of data is performed at different resolution values. For each value the clusters are displayed over a UMAP together with a plot showing the density of cells. 

```{r plot_clusters_integration, fig.height = 5, fig.width = 11, results = "asis"}
for (res in res_ls) {
  cat('#### ', res, '\n')
  g_cl    = plot_umap_cluster(
    umap_dt   = int_dt[, .(cell_id, UMAP1, UMAP2) ], 
    clust_dt  = int_dt[, .(cell_id, cluster = get(paste0('RNA_snn_res.', res))) ],
    name      = sprintf('res = %s', res))
  g_dens  = plot_umap_density(int_dt[, .(cell_id, UMAP1, UMAP2) ])
  g       = g_cl + g_dens
  print(g)
  cat('\n\n')
}
```

### Evaluating cluster distribution across samples{.tabset}

This plot visualizes the relationship between the entropy of clusters and the maximum proportion of cells from a single sample within each cluster (higher values suggest that a cluster predominantly contains cells from a single sample).
Entropy measures how evenly distributed cells are across samples within each clusterâ€”higher entropy indicates that cells from different samples are more evenly distributed, while lower entropy suggests that a cluster is dominated by cells from a small number of samples.

```{r plot_entropy_selected_clusters, fig.height = 5, fig.width = 7, results = "asis"}
for (res in res_ls) {
  cat('#### ', res, '\n')
  input_dt  = int_dt[, .(sample_id, cell_id, cluster = get(paste0('RNA_snn_res.', res)))]
  suppressWarnings(print(plot_cluster_entropies(input_dt, what = "norm")))
  cat('\n\n')
}
```


### QC metrics of clusters{.tabset}

Distributions of QC metrics (library size, number of features, mitochondrial proportion, and spliced proportion) are shown for each cluster across different resolution values.

```{r plot_qc_distns, fig.height = 8, fig.width = 10, results = 'asis'}
for (res in res_ls) {
  cat('#### ', res, '\n')
  suppressWarnings(print(plot_cluster_qc_distns(
    qc_melt, 
    clust_dt  = int_dt[, .(cell_id, cluster = get(paste0('RNA_snn_res.', res)))], 
    name      = res)))
  cat('\n\n')
}
```

${meta_bars_title}
${meta_bars_txt}

```{r plot_clusters_by_metadata, eval = do_metadata, fig.height = (2*length(metadata_vars)) + 1, fig.width = 8, results = 'asis'}

if (!is.null(metadata_vars))
  (plot_clusters_by_metadata(meta_dt, sel_cl_int_dt, 
    meta_vars = metadata_vars, cl_order = cl_ord))
```

${meta_umap_title}
${meta_umap_txt}

```{r plot_metadata_over_UMAP, eval = do_metadata, fig.height = 5, fig.width = 8, results = 'asis'}
for (meta_var in metadata_vars) {
  cat('####', meta_var, '\n')
  print(plot_clusters_annotated_by_densities(sel_cl_int_dt, meta_var))
  cat('\n\n')
}
```


## Marker genes

To identify marker genes for each cluster (resolution: `r sel_res`), pseudobulk counts are generated by aggregating the expression values of cells
within a specific cluster for each sample. Similarly, pseudobulk counts are generated for the remaining clusters
by aggregating expression values separately for each sample. The resulting pseudobulk values for the target cluster
are then compared to those of the remaining clusters using `edgeR`.

### Heatmaps of marker genes{.tabset}

The resulting `log2` fold change values (calculated using `edgeR`) per cluster are 
shown for several genesets:

- selected canonical marker genes, if specified in the config file;
- the 50 most highly variable genes; and
- the 50 genes most likely to represent ambient RNA contamination.

```{r plot_marker_heatmaps, fig.height = 9, fig.width = 10, results = 'asis'}
for (nn in names(mkrs_ls)) {
  cat("#### ", nn, "\n")
  suppressMessages(draw( plot_heatmap_of_selected_genes(mkrs_dt, mkrs_ls[[nn]]),
    heatmap_legend_side = "bottom", annotation_legend_side = "bottom", merge_legend = TRUE ))
  cat("\n\n")
}
```

### Highly variable genes{.tabset}
Normalized pseudobulk expression values for top 100 highly variable genes are shown 
for each cluster, in descending order of variance (variance calculated using `DESeq2::vst`).

```{r plot_hvgs_pb_hmny, fig.height = 8, fig.width = 8, results = "asis"}
n_pages = 10
per_p   = 10
p       = 1
for (i in seq(1, n_pages * per_p, by = per_p)) {
  cat('#### page', p, '\n'); p = p + 1
  sel_hvgs  = mkrs_hvgs_dt[ i:(i + 9) ]
  print(plot_selected_genes(sel_hvgs, cpms_dt, cl_order = cl_ord))
  cat('\n\n')
}
```

### Top marker genes{.tabset}

Normalized pseudobulk expression values of top 10 marker genes with FDR < 0.05 
and a minimum expression of `r min_cpm_mkr` CPM are shown for each cluster.

```{r plot_top_markers_pb_min, fig.height = 8, fig.width = 8, results = "asis"}
for (sel_cl in cl_ord) {
  cat('####', sel_cl, '\n')
  print(plot_top_marker_genes(sel_cl, top_min_dt, cpms_dt, cl_order = cl_ord))
  cat('\n\n')
}
```

${fgsea_title}
${fgsea_txt}

```{r plot_gsea_results_pb, eval = do_gsea, fig.height = 12, fig.width = 8, results = "asis"}
for (p in names(gsea_ls)) {
  if (is.null(gsea_ls[[p]]))
    next
  cat('#### ', p, '\n')
  dt    = gsea_ls[[p]] %>% .[ gsea_var == "z_score" ]
  plot_gsea_dotplot(dt, gsea_cut = gsea_cut, n_top_paths = 5, max_nes = 2,
    size_range = c(10, 200), what = "pos_only", cl_order = cl_ord) %>% print
  cat('\n\n')
}
```

## R session info

Details of the R package versions used are given below.

<details>
```{r session_info, include=TRUE, echo=TRUE, results="markup"}
devtools::session_info()
```
</details>
